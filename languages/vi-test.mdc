---
description: 
globs: 
alwaysApply: true
---
# Vitest 모범 사례 및 코딩 표준

이 문서는 신뢰성 있고, 유지보수가 용이하며, 성능이 좋은 테스트 스위트를 만들기 위한 Vitest 모범 사례를 개략적으로 설명합니다. 코드 구성부터 성능 고려사항 및 보안 조치에 이르기까지 테스트의 다양한 측면을 다룹니다.

## 1. 코드 구성 및 구조

### 1.1 디렉토리 구조

* **테스트를 소스 코드 가까이 유지하세요:** 테스트 파일을 테스트 대상 컴포넌트나 모듈과 같은 디렉토리에 배치하세요. 이는 발견 가능성과 유지보수성을 향상시킵니다.[1]

```
src/
  components/
    MyComponent.vue
    MyComponent.spec.ts
    MyComponent.test.ts  # 대체 이름 지정
  utils/
    math.ts
    math.test.ts
  App.vue
  App.spec.ts
```

* **엔드투엔드 테스트나 공유 유틸리티를 위한 전용 `tests` 디렉토리를 사용하세요:** 대규모 프로젝트의 경우, 루트 레벨의 `tests` 디렉토리에 엔드투엔드 테스트, 특정 환경이 필요한 통합 테스트 또는 공유 테스트 유틸리티를 배치할 수 있습니다.[1]

```
tests/
  e2e/
    specs/
      home.spec.ts
    support/
      commands.ts
  unit/
    utils.test.ts # 일반 유틸리티용 테스트
  integration/
    db.setup.ts # 통합 테스트용 설정
src/ 
  ...
```

### 1.2 파일 이름 지정 규칙

* **일관된 이름 지정을 사용하세요:** 테스트 파일에 일관된 이름 지정 체계를 채택하세요. 일반적인 규칙은 다음과 같습니다:[1]
  * `[컴포넌트/모듈].spec.ts`
  * `[컴포넌트/모듈].test.ts`
  * `[컴포넌트/모듈].e2e.ts` (엔드투엔드 테스트용)

* **설명적이어야 합니다:** 테스트 파일이 무엇을 테스트하는지 명확하게 나타내도록 이름을 지정하세요. 예를 들어, `MyComponent.props.spec.ts`는 `MyComponent`의 특정 props를 테스트할 수 있습니다.[1]

### 1.3 모듈 구성

* **관련 테스트를 그룹화하세요:** `describe` 블록을 사용하여 테스트를 모듈로 구성하세요. 이는 가독성을 향상시키고 테스트 출력을 구조화하는 데 도움이 됩니다.[1]

```typescript
import { describe, it, expect } from 'vitest';
import { add } from './math';

describe('수학 함수', () => {
  describe('add', () => {
    it('두 숫자를 올바르게 더해야 합니다', () => {
      expect(add(2, 3)).toBe(5);
    });

    it('음수를 처리해야 합니다', () => {
      expect(add(-1, 1)).toBe(0);
    });
  });
});
```

### 1.4 컴포넌트 아키텍처

* **컴포넌트 로직을 별도로 테스트하세요:** 복잡한 로직을 컴포넌트에서 분리하여 테스트 가능한 별도의 함수나 모듈로 추출하세요. 이는 재사용성을 촉진하고 컴포넌트 테스트를 단순화합니다.[1]

* **컴포넌트 상호작용에 집중하세요:** 컴포넌트를 테스트할 때는 특정 props나 상태가 주어졌을 때 컴포넌트가 올바르게 렌더링되는지, 사용자 상호작용에 대응하여 올바른 이벤트를 발생시키는지 확인하는 데 집중하세요.[1]

### 1.5 코드 분할 전략

* **코드 분할을 테스트하세요:** 애플리케이션이 코드 분할을 사용하는 경우, 테스트가 다양한 코드 청크와 지연 로드된 모듈을 다루는지 확인하세요.[1]

* **동적 가져오기를 모킹하세요:** Vitest의 모킹 기능을 사용하여 테스트 중에 동적 가져오기를 시뮬레이션하세요.[1]

```typescript
import { describe, it, expect, vi } from 'vitest';

describe('동적 가져오기', () => {
  it('동적 가져오기를 모킹해야 합니다', async () => {
    const mockModule = { value: 'mocked' };
    vi.mock('./dynamic-module', () => ({
      default: mockModule,
    }));

    const dynamicModule = await import('./dynamic-module');
    expect(dynamicModule.default).toBe(mockModule);
  });
});
```

## 2. 일반적인 패턴 및 안티패턴

### 2.1 Vitest 특정 디자인 패턴

* **AAA (준비, 실행, 검증):** 명확성과 유지보수성을 위해 각 테스트 케이스를 AAA 패턴에 따라 구성하세요.[1]

```typescript
it('두 숫자를 올바르게 더해야 합니다', () => {
  // 준비
  const a = 2;
  const b = 3;

  // 실행
  const result = add(a, b);

  // 검증
  expect(result).toBe(5);
});
```

* **페이지 객체 모델(POM):** 엔드투엔드 테스트의 경우, 페이지 객체 모델을 사용하여 사용자 인터페이스의 세부 사항을 추상화하고 UI 변경에 더 강건한 테스트를 만드세요. 다양한 페이지나 컴포넌트를 나타내는 전용 클래스를 정의하세요.[1]

### 2.2 일반적인 작업에 대한 권장 접근 방식

* **외부 의존성 모킹:** Vitest의 모킹 기능을 사용하여 테스트 중에 코드 단위를 격리하세요. 모듈을 모킹하려면 `vi.mock()`을, 특정 메서드나 속성을 감시하려면 `vi.spyOn()`을 사용하세요.[1]

* **비동기 코드 테스트:** 비동기 함수 테스트에는 `async/await`과 Vitest의 `expect.resolves` 및 `expect.rejects` 매처를 활용하세요.[1]

```typescript
it('올바른 값으로 해결되어야 합니다', async () => {
  await expect(Promise.resolve(42)).resolves.toBe(42);
});

it('에러로 거부되어야 합니다', async () => {
  await expect(Promise.reject(new Error('문제가 발생했습니다'))).rejects.toThrow('문제가 발생했습니다');
});
```

### 2.3 피해야 할 안티패턴 및 코드 스멜

* **과도한 모킹:** 모든 것을 모킹하지 마세요. 외부 의존성이나 테스트 대상이 아닌 컴포넌트만 모킹하세요. 실제 구현 대신 모크에 대해 테스트하면 테스트 신뢰도가 떨어집니다.[1]

* **불안정한 테스트:** 간헐적으로 통과하거나 실패하는 테스트는 근본적인 문제의 징후입니다. 경쟁 조건이나 외부 리소스에 대한 의존성과 같은 근본 원인을 식별하고 수정하기 위해 불안정한 테스트를 조사하세요.[1]

* **엣지 케이스 무시:** 테스트가 엣지 케이스, 오류 조건, 경계값을 포함한 모든 가능한 시나리오를 다루는지 확인하세요. "해피 패스"만 테스트하지 마세요.[1]

* **긴 테스트 함수:** 지나치게 복잡한 테스트 함수를 더 작고 집중된 테스트로 분해하세요. 이는 가독성을 향상시키고 실패 원인을 식별하기 쉽게 만듭니다.[1]

### 2.4 상태 관리 모범 사례

* **상태 격리:** Vuex, Pinia, Redux와 같은 상태 관리 라이브러리에 의존하는 코드를 테스트할 때는 테스트 중인 상태와 액션을 격리하세요.[1]

* **스토어 액션/게터 모킹:** 테스트 중에 상태를 제어하고 올바르게 호출되는지 확인하기 위해 액션과 게터를 모킹하세요.[1]

```typescript
import { describe, it, expect, vi } from 'vitest';
import { useStore } from './store';

describe('스토어 액션', () => {
  it('올바른 액션을 디스패치해야 합니다', () => {
    const store = useStore();
    const mockAction = vi.fn();
    store.dispatch = mockAction;

    store.commit('increment');
    expect(mockAction).toHaveBeenCalledWith('increment');
  });
});
```

### 2.5 오류 처리 패턴

* **오류 처리 테스트:** 테스트가 오류 처리 시나리오를 다루는지 확인하세요. 오류가 올바르게 발생하고 처리되는지 확인하기 위해 `try...catch` 블록이나 `expect.rejects`를 사용하세요.[1]

* **오류 응답 모킹:** API 응답을 모킹하여 오류 조건을 시뮬레이션하고 코드가 이를 어떻게 처리하는지 테스트하세요.[1]

## 3. 성능 고려사항

### 3.1 최적화 기술

* **병렬로 테스트 실행:** Vitest는 병렬 테스트 실행을 지원합니다. 테스트 실행 속도를 높이기 위해 이 기능을 활성화하세요.[1]

```json
// vitest.config.ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    threads: true,  // 병렬 실행 활성화
  },
})
```

* **`--changed`와 `--related` 플래그 사용:** 테스트를 실행할 때 마지막 커밋 이후 변경된 테스트만 실행하려면 `--changed` 플래그를, 특정 파일과 관련된 테스트를 실행하려면 `--related` 플래그를 사용하세요.[1]

```bash
vitest --changed
vitest --related src/components/MyComponent.vue
```

* **테스트 설정 최적화:** 각 테스트에 필요한 설정 양을 최소화하세요. 각 테스트 케이스마다가 아닌 각 테스트 스위트에 대해 한 번씩 설정 및 정리 작업을 수행하기 위해 `beforeAll`과 `afterAll` 훅을 사용하세요.[1]

### 3.2 메모리 관리

* **테스트 후 정리하세요:** 테스트가 메모리를 누수시키지 않도록 하세요. 모크나 임시 파일과 같이 테스트 중에 생성된 리소스를 정리하기 위해 `afterEach` 훅을 사용하세요.[1]

* **테스트에서 큰 객체 생성 피하기:** 메모리 소비를 줄이기 위해 테스트에서 생성하는 객체의 크기를 최소화하세요.[1]

### 3.3 렌더링 최적화

* **얕은 렌더링 사용:** 컴포넌트 테스트 시, 전체 컴포넌트 트리를 렌더링하지 않기 위해 얕은 렌더링을 사용하세요. 이는 테스트 성능을 크게 향상시킬 수 있습니다.[1]

```typescript
import { shallowMount } from '@vue/test-utils';
import MyComponent from './MyComponent.vue';

it('올바르게 렌더링되어야 합니다', () => {
  const wrapper = shallowMount(MyComponent);
  expect(wrapper.exists()).toBe(true);
});
```

### 3.4 번들 크기 최적화

* **테스트를 작게 유지하세요:** 테스트 파일에 불필요한 의존성을 포함하지 마세요. 이는 테스트의 번들 크기를 줄이고 시작 시간을 개선하는 데 도움이 될 수 있습니다.[1]

### 3.5 지연 로딩 전략

* **지연 로드된 모듈 모킹:** 지연 로딩을 사용하는 코드를 테스트할 때는 테스트 중에 로드되지 않도록 지연 로드된 모듈을 모킹하세요. 이는 테스트 성능을 향상시키고 의존성을 줄일 수 있습니다.[1]

## 4. 보안 모범 사례

### 4.1 일반적인 취약점과 예방 방법

* **크로스 사이트 스크립팅(XSS):** 사용자 입력을 정화하고 출력을 인코딩하여 XSS 취약점을 방지하세요. 테스팅 프레임워크도 취약하지 않은지 확인하세요. 플러그인 버전을 확인하세요.[1]

* **인젝션 공격:** 사용자 입력을 검증하고 매개변수화된 쿼리를 사용하여 인젝션 공격을 방지하세요.[1]

* **민감한 데이터 노출:** 테스트 파일에 민감한 데이터를 저장하지 마세요. 민감한 데이터를 관리하기 위해 환경 변수나 보안 구성 파일을 사용하세요.[1]

### 4.2 입력 검증

* **입력 검증 테스트:** 테스트가 입력 검증 시나리오를 다루는지 확인하세요. 코드가 사용자 입력을 올바르게 검증하고 유효하지 않은 입력을 우아하게 처리하는지 확인하세요.[1]

### 4.3 인증 및 권한 부여 패턴

* **인증 모킹:** 인증이 필요한 코드를 테스트할 때는 실제 API 호출을 피하기 위해 인증 서비스를 모킹하세요. 코드가 인증된 상태와 인증되지 않은 상태를 올바르게 처리하는지 확인하세요.[1]

* **권한 부여 테스트:** 테스트가 권한 부여 시나리오를 다루는지 확인하세요. 코드가 접근 제어를 올바르게 시행하고 리소스에 대한 무단 접근을 방지하는지 확인하세요.[1]

### 4.4 데이터 보호 전략

* **테스트에서 민감한 데이터 보호:** 테스트 파일에 민감한 데이터를 포함하지 마세요. 테스트에 모의 데이터나 익명화된 데이터를 사용하세요.[1]

### 4.5 보안 API 통신

* **API 응답 모킹:** 테스트 중에 실제 API 호출을 피하기 위해 API 응답을 모킹하세요. 보안 통신에는 HTTPS를 사용하세요.[1]

## 5. 테스트 접근 방식

### 5.1 단위 테스트 전략

* **개별 단위에 집중하세요:** 단위 테스트는 개별 함수, 클래스 또는 모듈을 격리된 상태에서 테스트하는 데 중점을 두어야 합니다. 단일 테스트에서 여러 코드 단위를 테스트하는 것을 피하세요.[1]

* **모든 코드 경로 테스트:** 단위 테스트가 일반 실행 경로, 오류 조건, 엣지 케이스를 포함한 모든 가능한 코드 경로를 다루는지 확인하세요.[1]

* **모크와 스텁 사용:** 코드 단위를 격리하고 테스트 중 동작을 제어하기 위해 모크와 스텁을 사용하세요.[1]

### 5.2 통합 테스트

* **단위 간 상호작용 테스트:** 통합 테스트는 서로 다른 코드 단위 간의 상호작용 테스트에 중점을 두어야 합니다. 코드 단위가 함께 올바르게 작동하는지 확인하세요.[1]

* **실제 의존성 사용:** 가능할 때마다 통합 테스트에서 실제 의존성을 사용하세요. 이는 코드가 실제 환경에서 올바르게 작동하는지 확인하는 데 도움이 될 수 있습니다.[1]

### 5.3 엔드투엔드 테스트

* **전체 애플리케이션 테스트:** 엔드투엔드 테스트는 사용자 인터페이스에서 백엔드 서비스까지 전체 애플리케이션 테스트에 중점을 두어야 합니다. 애플리케이션이 사용자 관점에서 올바르게 작동하는지 확인하세요.[1]

* **실제 브라우저 사용:** 엔드투엔드 테스트에 실제 브라우저를 사용하세요. 이는 애플리케이션이 다양한 브라우저와 환경에서 올바르게 작동하는지 확인하는 데 도움이 될 수 있습니다.[1]

### 5.4 테스트 구성

* **관련 테스트 그룹화:** `describe` 블록을 사용하여 테스트를 모듈로 구성하세요. 이는 가독성을 향상시키고 테스트 출력을 구조화하는 데 도움이 됩니다. (1.3 모듈 구성 참조)[1]

* **의미 있는 테스트 이름 사용:** 테스트가 무엇을 확인하는지 명확하게 나타내는 설명적인 테스트 이름을 사용하세요. 이는 테스트의 목적을 이해하고 실패 원인을 식별하기 쉽게 만듭니다.[1]

* **테스트를 짧고 집중적으로 유지하세요:** 테스트를 코드의 단일 측면에 집중하여 짧게 유지하세요. 이는 가독성을 향상시키고 테스트 유지보수를 용이하게 합니다.[1]

### 5.5 모킹 및 스터빙

* **상호작용 확인을 위해 모크 사용:** 함수가 올바른 인수로 호출되는지 확인하고 올바른 값을 반환하는지 확인하기 위해 모크를 사용하세요.[1]

* **동작 제어를 위해 스텁 사용:** 테스트 중에 함수의 동작을 제어하기 위해 스텁을 사용하세요. 이를 통해 다양한 시나리오를 시뮬레이션하고 코드가 이를 어떻게 처리하는지 테스트할 수 있습니다.[1]

* **과도한 모킹 피하기:** 테스트 대상이 아닌 의존성만 모킹하세요. 과도한 모킹은 테스트가 취약해지고 코드의 동작을 정확하게 반영하지 못하게 할 수 있습니다.[1]

## 6. 일반적인 함정과 주의사항

### 6.1 개발자가 자주 저지르는 실수

* **충분한 테스트를 작성하지 않음:** 버그를 잡고 회귀를 방지하기 위해 충분한 테스트 커버리지를 확보하세요.[1]

* **취약한 테스트 작성:** 코드의 구현 세부사항에 너무 밀접하게 연결된 테스트를 작성하지 마세요. 이는 테스트를 취약하게 만들고 유지보수를 어렵게 합니다.[1]

* **테스트 실패 무시:** 테스트 실패를 즉시 해결하세요. 테스트 실패를 무시하면 회귀로 이어질 수 있고 코드 유지보수가 더 어려워질 수 있습니다.[1]

### 6.2 알아야 할 엣지 케이스

* **Null 및 undefined 값:** 테스트가 값이 null이나 undefined인 시나리오를 다루는지 확인하세요.[1]

* **빈 문자열 및 배열:** 테스트가 문자열이나 배열이 비어 있는 시나리오를 다루는지 확인하세요.[1]

* **경계값:** 테스트가 숫자 타입의 최소값 및 최대값과 같은 경계값을 다루는지 확인하세요.[1]

### 6.3 버전별 이슈

* **Vitest를 최신 상태로 유지하세요:** 버그 수정, 성능 개선 및 새로운 기능의 혜택을 받기 위해 Vitest의 최신 버전을 유지하세요.[1]

### 6.4 호환성 문제

* **다양한 브라우저 및 환경에서 테스트하세요:** 호환성 문제를 잡기 위해 테스트가 다양한 브라우저 및 환경을 다루는지 확인하세요.[1]

### 6.5 디버깅 전략

* **디버깅 도구 사용:** 테스트를 단계별로 실행하고 실패 원인을 식별하기 위해 디버깅 도구를 활용하세요. Vitest는 인기 있는 디버거와 통합됩니다.[1]

* **명확하고 간결한 테스트 작성:** 테스트의 목적을 이해하고 실패 원인을 식별하기 쉽게 하기 위해 명확하고 간결한 테스트를 작성하세요.[1]

* **로깅 사용:** 실행 흐름을 추적하고 문제의 소스를 식별하는 데 도움이 되도록 테스트에 로깅 문을 추가하세요.[1]

## 7. 도구 및 환경

### 7.1 권장 개발 도구

* **Vitest 확장이 있는 VS Code:** Vitest 확장이 있는 VS Code는 테스트 발견, 실행 및 디버깅을 포함한 풍부한 개발 경험을 제공합니다.[1]

* **Vitest를 지원하는 다른 IDE:** WebStorm 및 IntelliJ IDEA와 같은 다른 많은 IDE도 Vitest 지원을 제공합니다.[1]

### 7.2 빌드 구성

* **빌드 도구 사용:** Vite나 esbuild와 같은 빌드 도구를 사용하여 코드를 번들링하고 테스트를 위해 최적화하세요.[1]

* **Vitest 구성:** 프로젝트 필요에 맞게 Vitest를 구성하세요. `vitest.config.ts` 파일을 사용하여 Vitest의 동작을 사용자 정의하세요.[1]

### 7.3 린팅 및 포맷팅

* **ESLint 및 Prettier 사용:** 일관된 코딩 스타일을 적용하고 잠재적 오류를 잡기 위해 ESLint 및 Prettier를 사용하세요. 이러한 도구를 개발 워크플로우에 통합하세요.[1]

### 7.4 배포 모범 사례

* **배포 전 테스트 실행:** 코드가 올바르게 작동하는지 확인하기 위해 항상 코드를 배포하기 전에 테스트를 실행하세요. CI/CD 파이프라인의 일부로 이 프로세스를 자동화하세요.[1]

### 7.5 CI/CD 통합

* **CI/CD 파이프라인과 Vitest 통합:** 모든 커밋에서 자동으로 테스트를 실행하기 위해 CI/CD 파이프라인과 Vitest를 통합하세요. 이는 버그를 조기에 잡고 회귀를 방지하는 데 도움이 됩니다.[1]

* **CI/CD 서비스 사용:** GitHub Actions나 GitLab CI와 같은 CI/CD 서비스를 사용하여 빌드, 테스트 및 배포 프로세스를 자동화하세요.[1]

## 결론

이러한 모범 사례를 따름으로써, 코드의 품질과 신뢰성을 보장하는 Vitest로 강력하고 유지보수 가능한 테스트 스위트를 만들 수 있습니다.[1]
