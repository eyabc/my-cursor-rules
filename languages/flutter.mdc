---
description: 
globs: 
alwaysApply: false
---
---
description: Flutter 개발을 위한 종합적인 가이드라인 및 모범 사례, 코드 구성, 성능 최적화, 보안, 테스팅, 도구 사용법 포함
globs: *.dart
---

- 공식 Flutter 스타일 가이드[https://github.com/flutter/flutter/blob/master/docs/contributing/Style-guide-for-Flutter-repo.md]를 준수하세요. 이는 유지보수 가능하고 일관된 코드의 기초가 됩니다.
- Flutter의 최신 안정 버전을 사용하고, 새로운 기능과 보안 패치를 지속적으로 업데이트하세요. 업데이트 시 Flutter의 주요 변경사항과 마이그레이션 가이드를 검토하세요.

## 1. 코드 구성 및 구조

- **1.1 디렉터리 구조 모범 사례:**
    - **`lib/` (소스 코드):**
        - 기능 기반 구조를 사용하여 관련 컴포넌트를 모듈로 그룹화하세요.
        - 예시:
           ```
           lib/
           ├── auth/
           │   ├── models/
           │   ├── providers/
           │   ├── screens/
           │   ├── services/
           │   ├── widgets/
           │   └── auth.dart
           ├── home/
           │   ├── models/
           │   ├── screens/
           │   ├── widgets/
           │   └── home.dart
           ├── common/
           │   ├── models/
           │   ├── widgets/
           │   └── utils/
           ├── core/
           │   ├── services/
           │   ├── theme/
           │   └── utils/
           ├── main.dart
           └── app.dart
           ```
    - **`test/` (테스트):** 쉬운 테스트 발견을 위해 `lib/` 구조를 미러링하세요.
    - **`android/`, `ios/`, `web/`, `macos/`, `windows/`, `linux/` (플랫폼별 코드):** 플랫폼별 네이티브 코드를 포함합니다. 필요한 경우가 아니면 직접 수정을 제한하고 Flutter의 플랫폼 채널을 활용하세요.
    - **`assets/` (자산):** 이미지, 폰트 및 기타 정적 리소스를 저장합니다. 타입별로 하위 폴더를 구성하세요(예: `images/`, `fonts/`, `data/`). `pubspec.yaml`을 사용하여 자산을 선언하세요.

- **1.2 파일 명명 규칙:**
    - 파일명에는 `snake_case`를 사용하세요(예: `user_profile_screen.dart`).
    - 파일 내 클래스의 경우, 파일명은 일반적으로 포함된 주요 클래스를 반영합니다. 예시: `UserProfileScreen`을 포함하는 `user_profile_screen.dart`.
    - 예외: 여러 관련 열거형, typedef 또는 작은 헬퍼 함수를 하나의 파일로 그룹화하는 것은 명확성을 향상시킬 경우 허용됩니다.

- **1.3 모듈 구성:**
    - 모듈은 특정 기능을 캡슐화합니다. 모듈은 잘 정의된 인터페이스를 가져야 하며 다른 모듈에 대한 의존성을 최소화해야 합니다.
    - 각 모듈 내에서 계층화된 아키텍처를 구현하세요(예: UI, 비즈니스 로직, 데이터 액세스).
    - 크고 독립적인 기능에 대해서는 패키지 사용을 고려하여 프로젝트 간 재사용성을 촉진하세요.

- **1.4 컴포넌트 아키텍처:**
    - Flutter 위젯을 사용한 컴포넌트 기반 아키텍처를 선호하세요. 복잡한 UI를 작고 재사용 가능한 위젯으로 분해하세요.
    - 프레젠테이션 로직과 비즈니스 로직을 분리하세요.
    - 위젯은 입력 데이터(상태)의 순수 함수여야 합니다.
    - 위젯 설계에 단일 책임 원칙(SRP)을 따르세요.

- **1.5 코드 분할 전략:**
    - **지연 로딩:** 초기 앱 크기를 줄이기 위해 필요에 따라 기능을 로드하세요.
    - **라우트 기반 분할:** 앱 라우트를 기반으로 코드를 분할하세요.
    - **기능 기반 분할:** 기능을 기반으로 코드를 분할하세요.
    - `dart:ui` 라이브러리의 `loadFontFromList` 또는 `ImageProvider.loadBuffer`를 사용하여 폰트나 이미지 리소스를 동적으로 로드하세요.

## 2. 일반적인 패턴 및 안티패턴

- **2.1 Flutter 특화 디자인 패턴:**
    - **BLoC (Business Logic Component):** 비즈니스 로직을 UI에서 분리하여 코드를 더 테스트 가능하고 유지보수 가능하게 만듭니다.
    - **Provider:** 간단한 의존성 주입 및 상태 관리 솔루션입니다.
    - **Riverpod:** 컴파일 타임 안전성을 갖춘 Provider의 개선된 버전입니다.
    - **GetX:** 상태 관리, 의존성 주입, 라우트 관리를 제공하는 마이크로프레임워크입니다.
    - **MVVM (Model-View-ViewModel):** 관심사 분리를 위한 또 다른 패턴입니다. 반응형 프로그래밍과 함께 자주 사용됩니다.
    - **Redux/Flux:** 복잡한 애플리케이션에서 예측 가능한 상태 관리를 위해 사용됩니다.
    - **InheritedWidget:** 테마 및 구성을 위한 암시적 의존성 주입입니다.

- **2.2 일반적인 작업을 위한 권장 접근법:**
    - **상태 관리:** 앱의 복잡성에 맞는 상태 관리 솔루션을 선택하세요.
    - **네트워킹:** API 요청을 위해 `http` 패키지나 `dio`를 사용하세요.
    - **비동기 작업:** 비동기 작업 처리를 위해 `async/await`를 사용하세요.
    - **데이터 지속성:** 간단한 데이터 저장을 위해 `shared_preferences`를 사용하거나 구조화된 데이터를 위해 SQLite(`sqflite` 패키지) 또는 NoSQL 데이터베이스(`hive` 또는 `isar` 패키지)를 사용하세요.
    - **내비게이션:** 타입 안전한 내비게이션을 위해 `go_router` 또는 `auto_route`를 사용하세요.
    - **폼 처리:** 검증자와 함께 `Form` 위젯과 `TextFormField`를 사용하세요.

- **2.3 피해야 할 안티패턴 및 코드 스멜:**
    - **거대한 위젯:** 너무 많은 로직이나 UI 코드를 가진 위젯입니다. 작고 재사용 가능한 컴포넌트로 분해하세요.
    - **위젯 내 로직:** 위젯 내에 비즈니스 로직을 직접 넣는 것을 피하세요.
    - **깊게 중첩된 위젯:** 성능 문제와 읽기 어려운 코드로 이어질 수 있습니다. 위젯 트리를 단순화하세요.
    - **관리되지 않는 상태:** `StreamSubscription`이나 `AnimationController`와 같은 리소스를 해제하지 않아 메모리 누수가 발생합니다.
    - **하드코딩된 값:** 코드에서 색상, 크기, 문자열과 같은 값을 하드코딩하는 것을 피하세요. 상수나 테마 데이터를 사용하세요.
    - **오류 무시:** 예외를 적절히 처리하지 않으면 예상치 못한 크래시가 발생할 수 있습니다. `try-catch` 블록과 로깅을 사용하세요.

- **2.4 상태 관리 모범 사례:**
    - 앱의 복잡성에 맞는 상태 관리 솔루션을 선택하세요.
    - 상태를 필요한 곳에 최대한 가깝게 유지하세요. 모든 것에 전역 상태를 사용하지 마세요.
    - 예상치 못한 상태 변경을 방지하기 위해 불변 데이터 구조를 사용하세요.
    - 테스트 가능성을 향상시키기 위해 상태를 UI 컴포넌트에서 분리하세요.
    - 부작용을 적절히 관리하세요.
    - 복잡한 상태 전환을 위해 스트림을 사용한 반응형 프로그래밍을 고려하세요.

- **2.5 오류 처리 패턴:**
    - 예외를 처리하기 위해 `try-catch` 블록을 사용하세요.
    - 특정 오류 시나리오를 위한 커스텀 오류 클래스를 구현하세요.
    - 디버깅을 위해 오류를 파일이나 원격 서비스에 로그하세요.
    - 사용자 친화적인 오류 메시지를 표시하세요.
    - 커스텀 오류 화면을 표시하기 위해 `ErrorWidget`을 사용하세요.
    - `Future.catchError` 또는 `Stream.handleError`를 사용하여 비동기 오류를 처리하세요.

## 3. 성능 고려사항

- **3.1 최적화 기법:**
    - **불필요한 위젯 재빌드 방지:** 불변 위젯에 `const` 생성자를 사용하고, `StatefulWidget`에서 `shouldRebuild` 메서드를 사용하며, 리스트에서 위치가 변경되는 위젯에 `ValueKey`를 사용하세요.
    - **`setState` 호출 최소화:** 상태 업데이트를 최적화하기 위해 상태 관리 솔루션을 사용하세요.
    - **`ListView.builder` 또는 `GridView.builder` 사용:** 큰 리스트나 그리드의 경우 위젯을 지연 빌드하세요.
    - **`RepaintBoundary` 사용:** 자주 다시 그려질 필요가 없는 UI 부분을 격리하세요.
    - **`Opacity`와 `Clip` 신중하게 사용:** 이러한 작업은 비용이 많이 들 수 있습니다.
    - **`Transform` 신중하게 사용:** 변환은 배칭을 깨뜨리고 추가 드로우 콜을 발생시킬 수 있습니다.

- **3.2 메모리 관리:**
    - `dispose` 메서드에서 `StreamSubscription`, `AnimationController`, `TextEditingController`와 같은 리소스를 해제하세요.
    - 불필요한 객체 생성을 피하세요.
    - 메모리 누수를 식별하기 위해 `dart:developer` 패키지의 메모리 프로파일링 도구를 사용하세요.
    - 전역 변수와 정적 필드의 사용을 최소화하세요.

- **3.3 렌더링 최적화:**
    - 성능 병목 지점을 식별하기 위해 Flutter Performance Overlay를 사용하세요.
    - 위젯 트리의 복잡성을 줄이세요.
    - 이미지 로딩과 캐싱을 최적화하세요.
    - 필요한 경우가 아니면 커스텀 페인트 작업 사용을 피하세요.

- **3.4 번들 크기 최적화:**
    - ABI(Application Binary Interface)별로 APK/AAB를 분할하기 위해 `flutter build apk --split-per-abi` 또는 `flutter build appbundle`을 사용하세요.
    - 사용하지 않는 자산과 코드를 제거하세요.
    - 이미지를 압축하세요.
    - 코드 난독화와 최소화를 사용하세요.
    - 자주 사용되지 않는 기능에 지연 로딩을 사용하세요.

- **3.5 지연 로딩 전략:**
    - **이미지 지연 로딩:** 화면에 보일 때만 이미지를 로드하세요.
    - **데이터 지연 로딩:** 사용자가 스크롤할 때 데이터를 청크 단위로 로드하세요.
    - 위젯이 보이게 될 때를 감지하기 위해 `VisibilityDetector` 패키지를 사용하세요.
    - 큰 데이터셋에 페이지네이션이나 무한 스크롤을 사용하세요.

## 4. 보안 모범 사례

- **4.1 일반적인 취약점과 예방 방법:**
    - **데이터 인젝션:** SQL 인젝션, XSS 및 기타 인젝션 공격을 방지하기 위해 사용자 입력을 정제하세요.
    - **민감한 데이터 저장:** 민감한 데이터를 평문으로 저장하지 마세요. 암호화와 보안 저장 메커니즘을 사용하세요.
    - **안전하지 않은 API 통신:** 모든 API 통신에 HTTPS를 사용하세요.
    - **코드 변조:** 앱을 역공학하기 어렵게 만들기 위해 코드 난독화를 사용하세요.
    - **중간자 공격:** MITM 공격을 방지하기 위해 인증서 피닝을 구현하세요.

- **4.2 입력 검증:**
    - 클라이언트와 서버 측 모두에서 모든 사용자 입력을 검증하세요.
    - 데이터 제약 조건을 강제하기 위해 정규 표현식이나 커스텀 검증 로직을 사용하세요.
    - UI에 표시하기 전에 데이터를 적절히 인코딩하세요.

- **4.3 인증 및 권한 부여 패턴:**
    - OAuth 2.0이나 OpenID Connect와 같은 보안 인증 프로토콜을 사용하세요.
    - 추가 보안을 위해 다중 인증(MFA)을 구현하세요.
    - 민감한 데이터와 기능에 대한 접근을 제한하기 위해 역할 기반 접근 제어(RBAC)를 사용하세요.
    - 인증 토큰을 안전하게 저장하세요.

- **4.4 데이터 보호 전략:**
    - 저장 시와 전송 시 민감한 데이터를 암호화하세요.
    - Keychain(iOS)이나 Keystore(Android)와 같은 보안 저장 메커니즘을 사용하세요.
    - 데이터에 대한 접근 권한을 부여할 때 최소 권한 원칙을 따르세요.

- **4.5 보안 API 통신:**
    - 모든 API 통신에 HTTPS를 사용하세요.
    - 적절한 인증과 권한 부여를 구현하세요.
    - API 응답을 검증하세요.
    - 남용을 방지하기 위해 API 요청을 속도 제한하세요.

## 5. 테스팅 접근법

- **5.1 단위 테스트 전략:**
    - 개별 함수, 클래스, 위젯을 격리하여 테스트하세요.
    - 테스트 대상 코드를 의존성으로부터 격리하기 위해 모의 객체를 사용하세요.
    - 모든 중요한 비즈니스 로직에 대한 테스트를 작성하세요.

- **5.2 통합 테스트:**
    - 앱의 서로 다른 부분 간의 상호작용을 테스트하세요.
    - API와 데이터베이스와 같은 외부 서비스와의 통합을 테스트하세요.

- **5.3 엔드투엔드 테스트:**
    - 앱 전체를 처음부터 끝까지 테스트하세요.
    - 앱이 예상대로 작동하는지 확인하기 위해 사용자 상호작용을 시뮬레이션하세요.

- **5.4 테스트 구성:**
    - `lib/` 디렉터리 구조를 미러링하는 `test/` 디렉터리를 생성하세요.
    - 설명적인 테스트 이름을 사용하세요.
    - 테스트를 작고 집중적으로 유지하세요.

- **5.5 모킹과 스터빙:**
    - 모의 객체를 생성하기 위해 `mockito`와 같은 모킹 프레임워크를 사용하세요.
    - 외부 의존성을 미리 정의된 값으로 대체하기 위해 스터빙을 사용하세요.
    - 테스트의 효과를 떨어뜨릴 수 있으므로 과도한 모킹을 피하세요.

## 6. 일반적인 함정과 주의사항

- **6.1 개발자가 자주 하는 실수:**
    - 리소스를 해제하지 않음
    - 오류를 무시함
    - 값을 하드코딩함
    - `setState`를 과도하게 사용함
    - 거대한 위젯을 생성함
    - 사용자 입력을 검증하지 않음
    - 상태 관리를 과도하게 복잡하게 만듦

- **6.2 주의해야 할 엣지 케이스:**
    - 네트워크 연결 문제
    - 기기 방향 변경
    - 백그라운드 앱 상태
    - 낮은 메모리 조건
    - 현지화 및 국제화

- **6.3 버전별 문제:**
    - 새로운 Flutter 릴리스의 주요 변경사항을 인지하세요.
    - 호환성을 보장하기 위해 다른 Flutter 버전에서 앱을 테스트하세요.
    - 필요한 Flutter 버전을 지정하기 위해 `pubspec.yaml`에서 버전 제약을 사용하세요.

- **6.4 호환성 고려사항:**
    - 다른 기기와 운영 체제에서 앱을 테스트하세요.
    - 장애가 있는 사용자를 위한 접근성을 고려하세요.
    - UI와 기능에 대한 플랫폼별 가이드라인을 따르세요.

- **6.5 디버깅 전략:**
    - 디버깅과 프로파일링을 위해 Flutter DevTools를 사용하세요.
    - 오류를 추적하기 위해 로깅을 사용하세요.
    - 코드를 단계별로 실행하기 위해 중단점을 사용하세요.
    - 위젯 트리를 검사하기 위해 Flutter Inspector를 사용하세요.

## 7. 도구 및 환경

- **7.1 권장 개발 도구:**
    - Visual Studio Code 또는 Android Studio
    - Flutter DevTools
    - Android Emulator 또는 iOS Simulator
    - 버전 관리를 위한 Git

- **7.2 빌드 구성:**
    - 다른 플랫폼용으로 앱을 빌드하기 위해 `flutter build`를 사용하세요.
    - `pubspec.yaml`에서 빌드 설정을 구성하세요.
    - 개발, 스테이징, 프로덕션을 위한 다른 빌드 구성을 사용하세요.

- **7.3 린팅과 포매팅:**
    - 린팅을 위해 `flutter_lints` 패키지를 사용하세요.
    - 코드 포매팅을 위해 `dart format` 또는 Prettier를 사용하세요.
    - 저장 시 자동으로 코드를 포맷하도록 IDE를 구성하세요.

- **7.4 배포 모범 사례:**
    - 각 플랫폼의 배포 가이드라인을 따르세요.
    - 앱의 진위성을 보장하기 위해 코드 서명을 사용하세요.
    - 릴리스를 관리하기 위해 버전 관리를 사용하세요.
    - 배포 후 앱의 크래시와 오류를 모니터링하세요.

- **7.5 CI/CD 통합:**
    - 빌드, 테스트, 배포 프로세스를 자동화하기 위해 GitHub Actions, GitLab CI, Jenkins와 같은 CI/CD 도구를 사용하세요.
    - 린팅, 포매팅, 테스팅을 실행하도록 CI/CD 파이프라인을 구성하세요.
    - 앱 스토어로의 릴리스 프로세스를 자동화하세요.

이 문서는 Flutter 개발을 위한 종합적인 가이드라인과 모범 사례를 제공합니다. 이러한 가이드라인을 따르면 유지보수 가능하고 성능이 뛰어나며 안전한 Flutter 앱을 작성하는 데 도움이 됩니다.
